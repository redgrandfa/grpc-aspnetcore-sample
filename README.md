# Implementing gRPC in ASP.NET Core 8

Browsers don't support gRPC, so this demonstrates backend-to-backend communication.

## .proto Sample: One Service Definition with 3 Types of gRPC Communication Patterns

### 1. Unary (Single Request / Single Response)
A basic request-response call.  
_Example_: Echo a message string back.

### 2. Server Streaming
Client sends one request, server responds with a stream of values.  
_Example_: Countdown from 3.

### 3. Bidirectional Streaming
Client and server continuously exchange messages.  
_Example_: EchoChat: Client sends messages, server echoes each message back in real time.

---
## Server (Start from Visual Studio gRPC Server Project Template)
- Additional NuGet package:
    - `Grpc.Tools`

- The `.csproj` file needs to include `.proto` files and set `GrpcServices="Server"`.
- The class `<proto service name>.<proto service name>Base` is auto-generated by the framework.
    - All `rpc` methods will have corresponding generated methods named as `<rpc>`. Override them to implement custom logic.

## Client 
- Additional NuGet packages:
    - `Google.Protobuf`: for serialization/deserialization
    - `Grpc.Net.Client`: required for gRPC client functionality
    - `Grpc.Net.ClientFactory`: helps register the gRPC server when implementing the client as an SDK
    - `Grpc.Tools`: for converting `.proto` files to C# classes

- The `.csproj` file needs to include `.proto` files and set `GrpcServices="Client"`.
- The class `<proto service name>.<proto service name>Client` is auto-generated by the framework.
    - All `rpc` methods will have corresponding `<rpc>` and `<rpc>Async` methods generated.
    - Get the client instance via :
        - Dependency Injection :
            ```csharp
            // IServiceCollection.AddGrpcClient comes from the Client Factory package.
            // Behind the scenes, it adds an HttpClient via the HttpClient Factory to call the server.
            IServiceCollection.AddGrpcClient<X.XClient>(client =>
            {
                client.Address = new Uri("https://localhost:7227"); // grpc server url: port
            });

            ```
        - instantiate it manually:
            ```csharp
            var channel = Grpc.Net.Client.GrpcChannel.ForAddress("https://localhost:7227"); // grpc server url: port
            var client = new X.XClient(channel);
            ```

    - Call the auto-generated client methods to communicate.

Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GrpcSample.Client", "GrpcSample.Client\GrpcSample.Client.csproj", "{D30F2920-8B8F-4B8A-AD57-047CDE188533}"

## Communication  patterns:
### Unary: 
- Client:
```csharp
var response = client.SomeUnaryMethod(request)`
```

- Server:
```csharp
public override async Task<TRes> SomeUnaryMethod(
    TReq request, 
    ServerCallContext context)
{
    return ( 【TRes instance】 )
}
```


### Server Streaming: 
- Client:
```csharp
using var call = client.SomeServerStreamingMethod(request);

while (await call.ResponseStream.MoveNext(cancellationToken))
{
    var msg = call.ResponseStream.Current;
}
```

- Server:
```csharp
public override async Task SomeServerStreamingMethod(
        TReq request,
        IServerStreamWriter<TRes> responseStream,
        ServerCallContext context)
{
    //use request

    await responseStream.WriteAsync(【TRes instance】);
}
```


### Bidirectional Streaming: 
- Client:
```csharp
using var call = client.SomeBidirectionalStreamingMethod();

var sendTask = Task.Run(async () =>
{
    await call.RequestStream.WriteAsync(【TReq instance】);

    // await call.RequestStream.CompleteAsync(); // end 
});

var receiveTask = Task.Run(async () =>
{
    await foreach (var response in call.ResponseStream.ReadAllAsync())
    {
        // use response
    }
});

await Task.WhenAll(sendTask, receiveTask);
```

- Server:
```csharp
public override async Task SomeBidirectionalStreamingMethod(
    IAsyncStreamReader<TReq> requestStream,
    IServerStreamWriter<TRes> responseStream,
    ServerCallContext context)
{
    // receive: 
    await foreach (var request in requestStream.ReadAllAsync(context.CancellationToken))
    {
        // use request
    }

    // send: 
    await responseStream.WriteAsync(【TRes instance】);
}
```
